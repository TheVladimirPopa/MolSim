// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "input.hxx"

// simulation_t
// 

const simulation_t::SimTypes_sequence& simulation_t::
SimTypes () const
{
  return this->SimTypes_;
}

simulation_t::SimTypes_sequence& simulation_t::
SimTypes ()
{
  return this->SimTypes_;
}

void simulation_t::
SimTypes (const SimTypes_sequence& s)
{
  this->SimTypes_ = s;
}

const simulation_t::InputFile_sequence& simulation_t::
InputFile () const
{
  return this->InputFile_;
}

simulation_t::InputFile_sequence& simulation_t::
InputFile ()
{
  return this->InputFile_;
}

void simulation_t::
InputFile (const InputFile_sequence& s)
{
  this->InputFile_ = s;
}

const simulation_t::endTime_type& simulation_t::
endTime () const
{
  return this->endTime_.get ();
}

simulation_t::endTime_type& simulation_t::
endTime ()
{
  return this->endTime_.get ();
}

void simulation_t::
endTime (const endTime_type& x)
{
  this->endTime_.set (x);
}

const simulation_t::deltaT_type& simulation_t::
deltaT () const
{
  return this->deltaT_.get ();
}

simulation_t::deltaT_type& simulation_t::
deltaT ()
{
  return this->deltaT_.get ();
}

void simulation_t::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const simulation_t::writeOutFrequency_type& simulation_t::
writeOutFrequency () const
{
  return this->writeOutFrequency_.get ();
}

simulation_t::writeOutFrequency_type& simulation_t::
writeOutFrequency ()
{
  return this->writeOutFrequency_.get ();
}

void simulation_t::
writeOutFrequency (const writeOutFrequency_type& x)
{
  this->writeOutFrequency_.set (x);
}

const simulation_t::filename_type& simulation_t::
filename () const
{
  return this->filename_.get ();
}

simulation_t::filename_type& simulation_t::
filename ()
{
  return this->filename_.get ();
}

void simulation_t::
filename (const filename_type& x)
{
  this->filename_.set (x);
}

void simulation_t::
filename (::std::unique_ptr< filename_type > x)
{
  this->filename_.set (std::move (x));
}


// array_i
// 

const array_i::x_type& array_i::
x () const
{
  return this->x_.get ();
}

array_i::x_type& array_i::
x ()
{
  return this->x_.get ();
}

void array_i::
x (const x_type& x)
{
  this->x_.set (x);
}

const array_i::y_type& array_i::
y () const
{
  return this->y_.get ();
}

array_i::y_type& array_i::
y ()
{
  return this->y_.get ();
}

void array_i::
y (const y_type& x)
{
  this->y_.set (x);
}

const array_i::z_type& array_i::
z () const
{
  return this->z_.get ();
}

array_i::z_type& array_i::
z ()
{
  return this->z_.get ();
}

void array_i::
z (const z_type& x)
{
  this->z_.set (x);
}


// array_d
// 

const array_d::x_type& array_d::
x () const
{
  return this->x_.get ();
}

array_d::x_type& array_d::
x ()
{
  return this->x_.get ();
}

void array_d::
x (const x_type& x)
{
  this->x_.set (x);
}

const array_d::y_type& array_d::
y () const
{
  return this->y_.get ();
}

array_d::y_type& array_d::
y ()
{
  return this->y_.get ();
}

void array_d::
y (const y_type& x)
{
  this->y_.set (x);
}

const array_d::z_type& array_d::
z () const
{
  return this->z_.get ();
}

array_d::z_type& array_d::
z ()
{
  return this->z_.get ();
}

void array_d::
z (const z_type& x)
{
  this->z_.set (x);
}


// cuboid_t
// 

const cuboid_t::position_type& cuboid_t::
position () const
{
  return this->position_.get ();
}

cuboid_t::position_type& cuboid_t::
position ()
{
  return this->position_.get ();
}

void cuboid_t::
position (const position_type& x)
{
  this->position_.set (x);
}

void cuboid_t::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const cuboid_t::dimension_type& cuboid_t::
dimension () const
{
  return this->dimension_.get ();
}

cuboid_t::dimension_type& cuboid_t::
dimension ()
{
  return this->dimension_.get ();
}

void cuboid_t::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void cuboid_t::
dimension (::std::unique_ptr< dimension_type > x)
{
  this->dimension_.set (std::move (x));
}

const cuboid_t::velocity_type& cuboid_t::
velocity () const
{
  return this->velocity_.get ();
}

cuboid_t::velocity_type& cuboid_t::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid_t::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid_t::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboid_t::distance_optional& cuboid_t::
distance () const
{
  return this->distance_;
}

cuboid_t::distance_optional& cuboid_t::
distance ()
{
  return this->distance_;
}

void cuboid_t::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void cuboid_t::
distance (const distance_optional& x)
{
  this->distance_ = x;
}

const cuboid_t::mass_optional& cuboid_t::
mass () const
{
  return this->mass_;
}

cuboid_t::mass_optional& cuboid_t::
mass ()
{
  return this->mass_;
}

void cuboid_t::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void cuboid_t::
mass (const mass_optional& x)
{
  this->mass_ = x;
}

const cuboid_t::type_optional& cuboid_t::
type () const
{
  return this->type_;
}

cuboid_t::type_optional& cuboid_t::
type ()
{
  return this->type_;
}

void cuboid_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void cuboid_t::
type (const type_optional& x)
{
  this->type_ = x;
}


// sphere_t
// 

const sphere_t::position_type& sphere_t::
position () const
{
  return this->position_.get ();
}

sphere_t::position_type& sphere_t::
position ()
{
  return this->position_.get ();
}

void sphere_t::
position (const position_type& x)
{
  this->position_.set (x);
}

void sphere_t::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const sphere_t::velocity_type& sphere_t::
velocity () const
{
  return this->velocity_.get ();
}

sphere_t::velocity_type& sphere_t::
velocity ()
{
  return this->velocity_.get ();
}

void sphere_t::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphere_t::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphere_t::radius_optional& sphere_t::
radius () const
{
  return this->radius_;
}

sphere_t::radius_optional& sphere_t::
radius ()
{
  return this->radius_;
}

void sphere_t::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphere_t::
radius (const radius_optional& x)
{
  this->radius_ = x;
}

const sphere_t::dimension_optional& sphere_t::
dimension () const
{
  return this->dimension_;
}

sphere_t::dimension_optional& sphere_t::
dimension ()
{
  return this->dimension_;
}

void sphere_t::
dimension (const dimension_type& x)
{
  this->dimension_.set (x);
}

void sphere_t::
dimension (const dimension_optional& x)
{
  this->dimension_ = x;
}

const sphere_t::distance_optional& sphere_t::
distance () const
{
  return this->distance_;
}

sphere_t::distance_optional& sphere_t::
distance ()
{
  return this->distance_;
}

void sphere_t::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void sphere_t::
distance (const distance_optional& x)
{
  this->distance_ = x;
}

const sphere_t::mass_optional& sphere_t::
mass () const
{
  return this->mass_;
}

sphere_t::mass_optional& sphere_t::
mass ()
{
  return this->mass_;
}

void sphere_t::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void sphere_t::
mass (const mass_optional& x)
{
  this->mass_ = x;
}

const sphere_t::type_optional& sphere_t::
type () const
{
  return this->type_;
}

sphere_t::type_optional& sphere_t::
type ()
{
  return this->type_;
}

void sphere_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void sphere_t::
type (const type_optional& x)
{
  this->type_ = x;
}


// simTypes_t
// 

const simTypes_t::Cuboid_sequence& simTypes_t::
Cuboid () const
{
  return this->Cuboid_;
}

simTypes_t::Cuboid_sequence& simTypes_t::
Cuboid ()
{
  return this->Cuboid_;
}

void simTypes_t::
Cuboid (const Cuboid_sequence& s)
{
  this->Cuboid_ = s;
}

const simTypes_t::Sphere_sequence& simTypes_t::
Sphere () const
{
  return this->Sphere_;
}

simTypes_t::Sphere_sequence& simTypes_t::
Sphere ()
{
  return this->Sphere_;
}

void simTypes_t::
Sphere (const Sphere_sequence& s)
{
  this->Sphere_ = s;
}


// input_t
// 

const input_t::path_type& input_t::
path () const
{
  return this->path_.get ();
}

input_t::path_type& input_t::
path ()
{
  return this->path_.get ();
}

void input_t::
path (const path_type& x)
{
  this->path_.set (x);
}

void input_t::
path (::std::unique_ptr< path_type > x)
{
  this->path_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// simulation_t
//

simulation_t::
simulation_t (const endTime_type& endTime,
              const deltaT_type& deltaT,
              const writeOutFrequency_type& writeOutFrequency,
              const filename_type& filename)
: ::xml_schema::type (),
  SimTypes_ (this),
  InputFile_ (this),
  endTime_ (endTime, this),
  deltaT_ (deltaT, this),
  writeOutFrequency_ (writeOutFrequency, this),
  filename_ (filename, this)
{
}

simulation_t::
simulation_t (const simulation_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SimTypes_ (x.SimTypes_, f, this),
  InputFile_ (x.InputFile_, f, this),
  endTime_ (x.endTime_, f, this),
  deltaT_ (x.deltaT_, f, this),
  writeOutFrequency_ (x.writeOutFrequency_, f, this),
  filename_ (x.filename_, f, this)
{
}

simulation_t::
simulation_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SimTypes_ (this),
  InputFile_ (this),
  endTime_ (this),
  deltaT_ (this),
  writeOutFrequency_ (this),
  filename_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void simulation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SimTypes
    //
    if (n.name () == "SimTypes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< SimTypes_type > r (
        SimTypes_traits::create (i, f, this));

      this->SimTypes_.push_back (::std::move (r));
      continue;
    }

    // InputFile
    //
    if (n.name () == "InputFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< InputFile_type > r (
        InputFile_traits::create (i, f, this));

      this->InputFile_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "endTime" && n.namespace_ ().empty ())
    {
      this->endTime_.set (endTime_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      this->deltaT_.set (deltaT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "writeOutFrequency" && n.namespace_ ().empty ())
    {
      this->writeOutFrequency_.set (writeOutFrequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "filename" && n.namespace_ ().empty ())
    {
      this->filename_.set (filename_traits::create (i, f, this));
      continue;
    }
  }

  if (!endTime_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "endTime",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "deltaT",
      "");
  }

  if (!writeOutFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "writeOutFrequency",
      "");
  }

  if (!filename_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "filename",
      "");
  }
}

simulation_t* simulation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_t (*this, f, c);
}

simulation_t& simulation_t::
operator= (const simulation_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SimTypes_ = x.SimTypes_;
    this->InputFile_ = x.InputFile_;
    this->endTime_ = x.endTime_;
    this->deltaT_ = x.deltaT_;
    this->writeOutFrequency_ = x.writeOutFrequency_;
    this->filename_ = x.filename_;
  }

  return *this;
}

simulation_t::
~simulation_t ()
{
}

// array_i
//

array_i::
array_i (const x_type& x,
         const y_type& y,
         const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

array_i::
array_i (const array_i& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

array_i::
array_i (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void array_i::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }
}

array_i* array_i::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class array_i (*this, f, c);
}

array_i& array_i::
operator= (const array_i& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

array_i::
~array_i ()
{
}

// array_d
//

array_d::
array_d (const x_type& x,
         const y_type& y,
         const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

array_d::
array_d (const array_d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

array_d::
array_d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void array_d::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }
}

array_d* array_d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class array_d (*this, f, c);
}

array_d& array_d::
operator= (const array_d& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

array_d::
~array_d ()
{
}

// cuboid_t
//

cuboid_t::
cuboid_t (const position_type& position,
          const dimension_type& dimension,
          const velocity_type& velocity)
: ::xml_schema::type (),
  position_ (position, this),
  dimension_ (dimension, this),
  velocity_ (velocity, this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
}

cuboid_t::
cuboid_t (::std::unique_ptr< position_type > position,
          ::std::unique_ptr< dimension_type > dimension,
          ::std::unique_ptr< velocity_type > velocity)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  dimension_ (std::move (dimension), this),
  velocity_ (std::move (velocity), this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
}

cuboid_t::
cuboid_t (const cuboid_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  dimension_ (x.dimension_, f, this),
  velocity_ (x.velocity_, f, this),
  distance_ (x.distance_, f, this),
  mass_ (x.mass_, f, this),
  type_ (x.type_, f, this)
{
}

cuboid_t::
cuboid_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  dimension_ (this),
  velocity_ (this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cuboid_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // dimension
    //
    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimension_type > r (
        dimension_traits::create (i, f, this));

      if (!dimension_.present ())
      {
        this->dimension_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!dimension_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimension",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      this->distance_.set (distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

cuboid_t* cuboid_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid_t (*this, f, c);
}

cuboid_t& cuboid_t::
operator= (const cuboid_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->dimension_ = x.dimension_;
    this->velocity_ = x.velocity_;
    this->distance_ = x.distance_;
    this->mass_ = x.mass_;
    this->type_ = x.type_;
  }

  return *this;
}

cuboid_t::
~cuboid_t ()
{
}

// sphere_t
//

sphere_t::
sphere_t (const position_type& position,
          const velocity_type& velocity)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  radius_ (this),
  dimension_ (this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
}

sphere_t::
sphere_t (::std::unique_ptr< position_type > position,
          ::std::unique_ptr< velocity_type > velocity)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  radius_ (this),
  dimension_ (this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
}

sphere_t::
sphere_t (const sphere_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  dimension_ (x.dimension_, f, this),
  distance_ (x.distance_, f, this),
  mass_ (x.mass_, f, this),
  type_ (x.type_, f, this)
{
}

sphere_t::
sphere_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  radius_ (this),
  dimension_ (this),
  distance_ (this),
  mass_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void sphere_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dimension" && n.namespace_ ().empty ())
    {
      this->dimension_.set (dimension_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      this->distance_.set (distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

sphere_t* sphere_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere_t (*this, f, c);
}

sphere_t& sphere_t::
operator= (const sphere_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->dimension_ = x.dimension_;
    this->distance_ = x.distance_;
    this->mass_ = x.mass_;
    this->type_ = x.type_;
  }

  return *this;
}

sphere_t::
~sphere_t ()
{
}

// simTypes_t
//

simTypes_t::
simTypes_t ()
: ::xml_schema::type (),
  Cuboid_ (this),
  Sphere_ (this)
{
}

simTypes_t::
simTypes_t (const simTypes_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Cuboid_ (x.Cuboid_, f, this),
  Sphere_ (x.Sphere_, f, this)
{
}

simTypes_t::
simTypes_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Cuboid_ (this),
  Sphere_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simTypes_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      this->Cuboid_.push_back (::std::move (r));
      continue;
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      this->Sphere_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

simTypes_t* simTypes_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simTypes_t (*this, f, c);
}

simTypes_t& simTypes_t::
operator= (const simTypes_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Cuboid_ = x.Cuboid_;
    this->Sphere_ = x.Sphere_;
  }

  return *this;
}

simTypes_t::
~simTypes_t ()
{
}

// input_t
//

input_t::
input_t (const path_type& path)
: ::xml_schema::type (),
  path_ (path, this)
{
}

input_t::
input_t (const input_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  path_ (x.path_, f, this)
{
}

input_t::
input_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  path_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void input_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "path" && n.namespace_ ().empty ())
    {
      this->path_.set (path_traits::create (i, f, this));
      continue;
    }
  }

  if (!path_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "path",
      "");
  }
}

input_t* input_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class input_t (*this, f, c);
}

input_t& input_t::
operator= (const input_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->path_ = x.path_;
  }

  return *this;
}

input_t::
~input_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::simulation_t > (
      ::Simulation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Simulation",
    "");
}

::std::unique_ptr< ::simulation_t >
Simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Simulation",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

